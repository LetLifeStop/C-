第二章 类型，运算符与表达式

* C语言只提供了一下几种基本数据类型：

  * char
  * int
  * float
  * double 

  还可以再这些基本的数据类型前面加上一点限定符，short和long 

* 某些字符可以通过专业字符表示为字符和字符串常量  

  ```c++
  '\000' 
  // 表示任意的字节大小的位模式
  '\xhh'
  // 表示十六进制
  ```

  字符常量 '\0' 表示值为0的字符，也就是空字符 null。 我们通常用 '\0'的形式代替0，用来强调某些表达式的**字符**属性，但是其数字值为0

*  'x' 和 "x" 是不同的，前者代表的是一个整数，而后者是一个包含一个字符（即字母x）以及一个结束符 '\0' 的字符数组

* 枚举常量是一个常量整形值的列表，比如

  ```c++
  enum boolean {NO, YES};
  ```

  在没有显式说明的情况下，enum类型中的第一个枚举名的值将按照最后一个指定的值往后递增。**不同枚举中的名字必须互不相同，同一枚举中的不同的名字可以具有相同的值**  

  枚举相对于define语句来说，优势在于常量值可以自动生成。尽管define可以声明为enum类型的变量，但是编译器不检查这种类型的变量中存储的值是否为该枚举的有效值。而枚举变量会提供这种检查，因此枚举比define更加有优势。 调试程序可以通过符号的形式打印出枚举变量的值

* 逻辑运算符 && 和 || 有一些较为特殊的属性，由 && 和 || 连接的表达式按照从左往右的顺序进行求值，并且在知道结果值为真或者假之后立即停止运算。**运算符 && 的优先级比 || 的优先级更高**，但是两者都比**关系运算符**和**相等运算符**的优先级低 

* 运算符 != 的优先级 高于 赋值运算符的优先级， 所以在表达式中 

  ```c++
  ( c = getchar() ) != '\n'
  ```

  需要圆括号将getchar复制出来

* 练习 2-2, 在不使用运算符 && 或者 || 条件下，编写一个和上面的for循环语句等价的循环语句

  ```c++
  for (i = 0; i < lim - 1 && (c=getchar()) != '\n' && c != EOF; i++)
  ```

* 类型转换

  将字符类型转换为整形时，需要注意C语言没有指定char类型的变量是有符号的还是没有符号的，对于不同的机器，结果也不同。 为了保证程序的可移植性，如果要在char类型的变量中，存储非字符数据，最好指定signed或者unsigned限定符。

* 一般来说，如果二元运算符（具有两个操作数的运算符称为二元运算符）的两个操作数具有不同的类型，那么在进行运算之前先要把 较低 的类型提升为 较高 的类型

* 表达式中的float类型的操作数不会自动转换为double类型，使用float类型主要是为了在使用较大的数组时姐生存储空间，也为了节省机器的执行时间

* 练习：编写htoi (s) 函数，把由十六进制数字组成的字符串（包含可选的前缀0x或者0X）转换为与之等价的整型值。字符串中允许包含的数组包括 : 0 ~ 9, a ~ f 以及 A ~ F 

* 对 &, | 同 && 和 || 进行区分，后者是按照从左往右进行计算的。如果 x = 1, y = 2， x & y 为 0，而 x && y 为1

* 注意在进行位移操作的时候，注意变量是符号类型的，还是无符号类型的。当右移的时候，填充位是不同的

* 一元运算符 +, -, &与*的优先级比相应的二元运算符+, -, &与\*的优先级高，一元运算符就是类似++，--这样的，只需要一个操作数就能解决

* 在形如 

  ```c++
  x = f() + g();
  ```

  中，f()可以在g()之后计算，也有可能提前，为了防止f的调用时间对g产生影响，可以分别用临时值存储。