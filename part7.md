第七章 输入与输出

* 在转过说明中，宽度或者精度可以用星号\*表示，这时，宽度或者精度的值通过转换下一个参数(**必须为int**)，例如，为了从字符串s中打印最多max个字符，可以使用如下语句

  ```c++
  printf("%.*s", max, s);
  ```

* 字符%和转换字符中间可能一次包含如下组成部分：

  * 负号，用于指定被转换的参数按照左对齐的形式输出
  * 数，用于指定最小字段宽度。转换后的参数将打印不小于最小字段宽度的字段。如果有必要，字段左边（如果是左对齐则是右边）多余的字符位置用空格填充来保证最小字段宽
  * 小数点，用于将字段宽度和精度分开
  * 数，用于指定精度
  * 字母h或者l，h表示将整数作为short类型打印，字母l表示将整数作为long类型打印

  ```c++
  通过printf输出字符串 "hello, world"， 在每个字段的左边和右边加上冒号，用来显示宽度
  :%s:         :hello, world:     // 原样输出
  :%10s:       :hello, world:     // 指定最小宽度为10
  :%.10s:      :hello, wor:       // 指定精度为10
  :%-10s:      :hello, world:     // 按照左对齐的方法，同时保证最小宽度为10
  :%.15s:      :hello, world    : // 指定精度为15
  :%15.10s:    :     hello,wor" : // 指定精度为10，并且最小宽度为15
  :%-15.10s:   :hello, wor      : // 指定精度为10，并且最小宽度为15，并且为左对齐 
  ```

* 变长参数表，标准头文件 \<stdarg.h\> 中包含一组宏定义，他们对如何遍历参数表进行了定义。var_list，用于声明一个变量，这个变量将一次引用各个参数

  https://www.cnblogs.com/baiduboy/p/6568069.html

  几个比较重要的宏定义

  ```c++
  typedef char* va_list;
  void va_start (va_list ap, prev_param);
  type va_arg(va_list ap, type);
  void va_end(va_list ap);
  ```

  va_list是一个字符指针，可以理解为指向当前参数的一个指针，取指针必须通过这个指针进行

  1. 在调用参数表之前，定义一个va_list类型的变量（假设va_list类型变量被定义为ap）
  2. 然后应该对ap进行初始化，让他指向可变参数表里面第一个参数，通过va_start来实现，第一个参数是ap本身，第二个参数是在变参表前面紧挨着的一个变量，也就是 ... 之前的参数
  3. 然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型。
  4. 获取所有的参数之后，需要将这个ap参数关掉，一面发生危险，方法是调用va_end

  ```c++
  void minprintf(char *fmt, ...)
  {
    va_list ap;
    char *p, *sval;
    int ival;
    double dval;
      
    va_Start(ap, fmt);
    for(p = fmt; *p; p++)
    {
      if(*p != '%')
      {
        putchar(*p);
        continue;
      }
        
      switch(*++p)
      {
          case 'd':
          .....
      }
      //...
    }
    va_end(ap);
  }
  ```

* 当scanf函数扫描完其格式串，或者碰到某些无法与格式控制说明匹配的情况时，该函数将终止，同时成功匹配并且赋值的输入项的个数将作为函数值返回。，所以返回值可以用来确定已经匹配的输入项的个数。如果到达文件的结尾，该函数将返回EOF。返回EOF和返回0是不同的，0代表下一个输入的字符和格式串中第一个格式说明不匹配。

* scanf函数忽略格式串中的空格和制表符，同时在读取输入值时，他将跳过空白符

* 无论调用哪一个输入函数，下一个输入函数的调用将从scanf没有读取的第一个字符处开始读取数据

* fopen函数

  ```c++
  File *fp;
  File *fopen(char *name, char *mode);
  ```

  返回值是file指针，该指针被称为文件指针，指向一个结构FILE，包含 缓冲区的位置，缓冲区中当前字符的位置，文件的读或者写状态

  fopen的第一个参数是一个字符串，包含文件名。第二个参数是访问模式，允许的模式包含 读（r），写（w），以及追加（a）。某些系统还区分文本文件和二进制文件，对二进制文件的访问需要在模式字符串后增加字符 b

* 如果打开一个不存在的文件用于追加或者写入，这个文件将被创建。如果通过写的方式打开一个已经存在的文件，该文件中原来的内容将被覆盖。如果通过追加的方式打开一个文件，文件原来的内容将保留不变。

* 文件的写入可以通过putc和getc。对于文件的格式化输入和输出，可以使用函数fscanf和fprintf，他们和scanf和printf的区别仅在于fscanf和fprintf的第一个参数是一个指向所要读写的文件的指针

* 函数fclose执行和fopen相反的操作，断开由fopen函数建立的文件指针和外部名之间的链接，并且释放文件以供其他文件使用，因为大多数os都限制一个程序可以同时打开的文件数。**fclose函数还有另外一个原因，他把缓冲回去的由putc函数正在收集的输出写到文件中。** 当程序正常重视时，程序会自动为每个打开的文件调用fclose函数

* stderr解决的问题如下：如果因为某种原因造成一个文件打开失败，在输出诊断信息的时候，如果存在管道，这样就会造成不必要的影响。为了处理这种情况，可以通过stderr，**即使对标准输出进行了重定位，stderr的输出也通常会显示在屏幕上**

* 程序使用exit将终止程序的执行。任何调用该程序的仅从都可以获取exit的参数值，0表示正常，因此可以通过另一个将该程序作为子进程的程序来测试程序的执行是否成功。exit为每个已经打开的输出文件调用flose函数，来将缓冲区中的所有输出写入到相应的文件中。在main程序中，return expr  等价于 exit（expr）。~~但是exit可以从其他的函数中调用~~

* 行输入和行输出，fgets函数从fp指向的文件中读取下一输入行（包括换行符），并将它存放在数组中。fputs函数将一个字符串写入到文件中。

* gets函数在读取字符串将删除结尾的换行符，而puts函数在写入字符串时将在结尾添加一个换行符。

* 命令执行函数，system(char *s)执行包含在字符串s中的命令，然后继续执行当前的程序

* 函数malloc和calloc用于动态的分配存储块，函数malloc当分配成功时，将返回一个指针，指向n字节长度的未初始化的存储空间。calloc分配成功时返回一个指针，指向空闲空间足以容纳由n个指定长度的对象组成的数组

  ```c++
  void *malloc(size_t  n);
  void *calloc(size_t n, size_t size);
  ```

  free（p）释放p指向的存储空间，其中p时 此前通过调用malloc或者calloc函数得到的指针。存储空间的释放并没有什么限制。但是如果释放一个不是通过malloc或者calloc函数得到的指针所指向的存储空间，将是一个很严重的错误。

  https://zhidao.baidu.com/question/446201894.html【为什么new申请的内容不能通过free释放】

  

