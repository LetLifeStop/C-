第八章 UNIX系统接口 

* open函数和fopen函数类似，open函数返回一个文件描述符，仅仅是一个int类型的数值。而后者返回一个文件指针, 如果发生错误，open将返回 -1

  ```c++
  int open(char *name, int flags, int perms);
  ```

  flag:

  * O_RDONLY 通过只读的方式打开文件
  * O_WRONLY 通过只写的方式打开文件
  * O_RDWR  通过读写的方式打开文件

* 如果用open打开一个不存在的文件，将会导致错误。可以使用create系统调用创建新的文件覆盖旧的文件。如果创建成功，返回一个fd，否则返回-1.如果这个文件已经存在，create将会把该文件的长度截断为0

* 如果要创建的文件不存在，create用参数perms指定的权限创建文件。在unix文件系统中，每一个文件对应的一个 **9** 比特的权限信息，分别控制文件的所有者，所有者组和其他成员对文件的读，写和执行访问 （r：4 w：2 x ：1）

* vprintf函数和printf函数类似，只不过前者用一个参数取代了变长参数表，并且通过va_start进行初始化

* 一个程序同时打开的文件数是有限制的（通常为20），相应的，如果一个程序要同时处理多个文件，那么就需要进行fd的重用。函数close用来断开文件描述符和已经打开文件之间的连接，并且释放这个fd

* close和fclose函数相对应，但是close不需要清洗缓冲区，fclose是和文件流相关的函数，close是和文件描述符相关的函数。 fopen，fclose是C标准函数，而open，close等其他类别是POSIX特有的，这意味着用open，close等编写的代码并不是标准的C代码，因此是不可移植的，用fopen，fclose等编写的代码是标准代码，可以移植到任何类型的系统上

* close关闭输出的时候并不会冲洗的缓冲区，而fclose隐含了一次fflush参数，会把缓冲区内的数据冲洗到终端，此时会有输出

  （fclose是标准io,printf也是使用标准io进行输出，fclose会调用一次fflush，使得标准io的缓冲通过write(系统的无缓冲io)进行输出。close是系统调用，在标准io的更底层，无法感知到标准io printf的缓冲区内容。所以不行）

* 函数unlink将文件name从文件系统中删除

* lseek函数，可以通过任意顺序访问文件。

  ```c++
  long lseek(int fd, long offset, int origin);
  ```

  origin的值可以为0，1，2.分别指定offset从文件开始，从当前位置或者从文件结束处开始算起。offset是相对于origin而言的，选定了位置后，可以相对origin设置偏移量。lseek返回一个long类型的值，这个值表示文件的新位置
  
* 标准库中的文件不是通过fd描述的，而是通过文件指针描述的。该结构包含下列内容，一个指向缓冲区的指针，一个记录缓冲区中剩余的字符数的计数器，一个指向缓冲区中下一个字符的指针，fd，描述读/写的标志，描述错误状态的标志等等（**函数实现需要再确定下**）

*  fize程序是ls命令的一个特殊形式，它打印命令行参数表中指定的所有文件的长度

* 在unix中，目录就是文件，分为两部分，一部分是文件名列表，一部分是指向inode节点表的指针。inode节点就是存放除了文件名以外的所有文件信息的地方， 目录项一般包含两个条目，文件名和inode节点编号

* 在不同版本的系统中，目录的格式和确切的内容是不一样的，为了分离出不可一致的部分，我们把任务分成两部分，外层定义了一个称为Dirent的结构和三个函数opendir，readdir，closedir。他们提供和系统无关的对目录项中的名字和i结构编号的访问

* 结构Dirent包含i节点编号和文件名。文件名的最大长度由NAME_MAX设定。opendir返回一个指向DIR的结构的指针，将供readdir和closedir使用

  ```c++
  # define NAME_MAX 14
  
  typedef struct 
  {
      long ino;
      char name[NAME_MAX];
  }Dirent;
  
  typedef struct 
  {
      int fd;
      Dirent d;
  }Dir;
  
  DIR *opendir(char *dirname);
  Dirent *readdir(DIR *dfd);
  void closedir(Dir *dfd);
  ```

* fsize打印文件的长度。但是如果该文件是一个目录，fsize会首先调配用dirwork函数处理它所包含的所有文件。dirwork会对目录中的文件调用第二个参数对应的函数。dirwalk首先打开目录，循环遍历其中的每一个文件，并且对文件调用该函数，然后关闭目录返回。

* malloc并不是从一个在编译的是偶就确定的固定大小的数组中分配存储空间，而是在需要的时候向操作系统申请空间，因为程序中的某些地方可能不通过malloc调用申请内存（通过其他方式申请空间）。所以，malloc管理的空间不一定是连续的，空闲的存储空间通过空闲块链表的方式组织，每一个块包含一个长度，一个指向下一块的指针以及一个指向自身存储空间的指针。这些快按照存储地址的升序组织。

* 当申请内存的时候，malloc将扫描空闲的链表，知道找打一个足够大的块为止。包括“首次适应” 算法和“最佳适应”算法。释放的过程中，首先搜索空闲块链表，用来找到可以插入被释放的合适位置，如果被释放块香菱的任一边是一个空闲块，九江这两个块合成一个更大的块

* 由malloc函数返回的存储空间满足将要保存的对象的对其要求。每个特定的机器都有一个最受限的类型，如果最受限的类型可以存储在某个特定的地址中，则其他所有的类型也可以存放在此地址中。(**不太理解为何要存在最受限的类型？是为了内存对齐吗？**)

* 空闲块包含 一个指向链表中下一个块的指针， 一个块大小的记录和一个指向空闲空间本身的指针。为了简化块的对齐，所有的块都必须是头部大小的整数倍，这是通过一个联合实现的

  ```c++
  typedef long Align;
  
  union header
  {
      struct 
      {
          union header *ptr; /*为什么这里有union*/
          unsigned size;
      }s;
      Align x; /* 强制块的对齐*/
  };
  
  typedef union header Header;
  ```

  在该联合中，Align字段永远不会被使用，它仅仅用于强制每个头部在最坏的情况下满足对齐要求。

* 在malloc函数中，请求的长度将被舍入，以保证它是头部大小的整数倍，malloc函数返回的指针将指向空闲空间，而不是块的头部

* 任何情况下，当请求空闲空间时，都将搜索空闲块链表。搜索从上一次找到空闲块的地方开始(freep)。如果是第一次调用malloc，系统将创建一个退化的空闲块链表

* 函数morecore是向os请求存储空间。每一次调用，至少申请malloc个单元，这个较大的单元将被分成较小的块，设置完size之后morecore函数调用free函数把多余的空闲的块放到空闲区域中

* unix系统调用sbrk（n）返回一个指针，这个指针指向n个字节的存储空间

* free函数，从freep指向的地址开始，诸葛扫描空闲块链表，寻找可以插入空闲块的地方。这个位置可能在两个空闲块之间，也有可能在链表的末尾，如果被释放的块和另外一个空闲块相邻，将这两个块合并起来（设置指针，并且这只正确的块大小）

