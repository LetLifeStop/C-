第八章 UNIX系统接口 

* open函数和fopen函数类似，open函数返回一个文件描述符，仅仅是一个int类型的数值。而后者返回一个文件指针, 如果发生错误，open将返回 -1

  ```c++
  int open(char *name, int flags, int perms);
  ```

  flag:

  * O_RDONLY 通过只读的方式打开文件
  * O_WRONLY 通过只写的方式打开文件
  * O_RDWR  通过读写的方式打开文件

* 如果用open打开一个不存在的文件，将会导致错误。可以使用create系统调用创建新的文件覆盖旧的文件。如果创建成功，返回一个fd，否则返回-1.如果这个文件已经存在，create将会把该文件的长度截断为0

* 如果要创建的文件不存在，create用参数perms指定的权限创建文件。在unix文件系统中，每一个文件对应的一个 **9** 比特的权限信息，分别控制文件的所有者，所有者组和其他成员对文件的读，写和执行访问 （r：4 w：2 x ：1）

* vprintf函数和printf函数类似，只不过前者用一个参数取代了变长参数表，并且通过va_start进行初始化

* 一个程序同时打开的文件数是有限制的（通常为20），相应的，如果一个程序要同时处理多个文件，那么就需要进行fd的重用。函数close用来断开文件描述符和已经打开文件之间的连接，并且释放这个fd

* close和fclose函数相对应，但是close不需要清洗缓冲区，fclose是和文件流相关的函数，close是和文件描述符相关的函数。 fopen，fclose是C标准函数，而open，close等其他类别是POSIX特有的，这意味着用open，close等编写的代码并不是标准的C代码，因此是不可移植的，用fopen，fclose等编写的代码是标准代码，可以移植到任何类型的系统上

* close关闭输出的时候并不会冲洗的缓冲区，而fclose隐含了一次fflush参数，会把缓冲区内的数据冲洗到终端，此时会有输出

  （fclose是标准io,printf也是使用标准io进行输出，fclose会调用一次fflush，使得标准io的缓冲通过write(系统的无缓冲io)进行输出。close是系统调用，在标准io的更底层，无法感知到标准io printf的缓冲区内容。所以不行）

* 函数unlink将文件name从文件系统中删除

* lseek函数，可以通过任意顺序访问文件。

  ```c++
  long lseek(int fd, long offset, int origin);
  ```

  origin的值可以为0，1，2.分别指定offset从文件开始，从当前位置或者从文件结束处开始算起。offset是相对于origin而言的，选定了位置后，可以相对origin设置偏移量。lseek返回一个long类型的值，这个值表示文件的新位置
  
* 标准库中的文件不是通过fd描述的，而是通过文件指针描述的。该结构包含下列内容，一个指向缓冲区的指针，一个记录缓冲区中剩余的字符数的计数器，一个指向缓冲区中下一个字符的指针，fd，描述读/写的标志，描述错误状态的标志等等（**函数实现需要再确定下**）

*  fize程序是ls命令的一个特殊形式，它打印命令行参数表中指定的所有文件的长度

* 在unix中，目录就是文件，分为两部分，一部分是文件名列表，一部分是指向inode节点表的指针。inode节点就是存放除了文件名以外的所有文件信息的地方， 目录项一般包含两个条目，文件名和inode节点编号

