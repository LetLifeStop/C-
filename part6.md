第六章 结构

* 如果传递给函数的结构很大，使用指针方式的效率通常比复制整个结构的效率要高。

  ```c++
  struct point *pp;
  ```

  可以使用如下的方式使用pp。

  ```c++
  struct point origin, *pp;
  pp = &origin;
  printf("%d %d\n", (*pp).x, (*pp.y));
  // 或者是如下的方法
  printf("%d %d\n", pp->x, pp->y);
  ```

  注意圆括号是必须要加的，因为结构成员运算符 “.” 的优先级要比 "*" 的优先级高 

  ```c++
  *pp.x 
  //等价于
  *(pp.x)
  ```

* 为了表示方便，C语言提供了另一种简写方式。

  ```c++
  struct rect r, *rp = &r;
  // 运算符 . 和 -> 都是从左至右结合的
  //以下四个表达式时等价的
  r.pt1.x
  rp->pt1.x
  (r.pt1).x
  (rp->pt1).x
  ```

* 小对比

  ```c++
  struct point origin, *pp;
  pp = &origin;
  
  struct point origin, *pp;
  *pp = &origin;
  // 这种是非法的
  
  struct point origin, *pp = &origin;
  ```
```
  
第一种情况和第三种情况起到的作用是相同的
  
* 在所有的运算符中，下面四个运算符的优先级最高，结构运算符 "."和 "->" ，由于函数调用 "()"以及用于下标的 "[]" 。因此，他们同操作数之间的结合也是最紧密的

  ```c++
  ++p->len
  // 等价于 ++(p->len)
  *p->str
  // 等价于 *(p->str)
  *p->str++
  // 先读取指针str指向的对象的是，然后+1，然后再读取对应的操作
  (*p->str)++
  // 将指针str指向的对象的值+1
  *p++->str
  // 先读取指针的值，然后再+1
```

* sizeof 返回一个整型值，等于指定对象或者类型占用的存储空间字节数（sizeof返回的是无符号整型值，类型为size_t）
* 条件编译语句#if 中不能使用sizeof，因为预处理器不对类型名进行分析。但是预处理器并不计算#define语句中的表达式。因此在#define中使用sizeof是合法的
* 两个指针之间的加法运算是非法的，但是减法运算是合法的
* 在C语言中，以重合适的方法是将malloc的返回值声明为要给指向void类型的指针，然后再显式的将该指针强制转换为所需的类型



