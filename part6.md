第六章 结构

* 如果传递给函数的结构很大，使用指针方式的效率通常比复制整个结构的效率要高。

  ```c++
  struct point *pp;
  ```

  可以使用如下的方式使用pp。

  ```c++
  struct point origin, *pp;
  pp = &origin;
  printf("%d %d\n", (*pp).x, (*pp.y));
  // 或者是如下的方法
  printf("%d %d\n", pp->x, pp->y);
  ```

  注意圆括号是必须要加的，因为结构成员运算符 “.” 的优先级要比 "*" 的优先级高 

  ```c++
  *pp.x 
  //等价于
  *(pp.x)
  ```

* 为了表示方便，C语言提供了另一种简写方式。

  ```c++
  struct rect r, *rp = &r;
  // 运算符 . 和 -> 都是从左至右结合的
  //以下四个表达式时等价的
  r.pt1.x
  rp->pt1.x
  (r.pt1).x
  (rp->pt1).x
  ```

* 小对比

  ```c++
  struct point origin, *pp;
  pp = &origin;
  
  struct point origin, *pp;
  *pp = &origin;
  // 这种是非法的
  
  struct point origin, *pp = &origin;
  ```
```
  
第一种情况和第三种情况起到的作用是相同的
  
* 在所有的运算符中，下面四个运算符的优先级最高，结构运算符 "."和 "->" ，由于函数调用 "()"以及用于下标的 "[]" 。因此，他们同操作数之间的结合也是最紧密的

  ```c++
  ++p->len
  // 等价于 ++(p->len)
  *p->str
  // 等价于 *(p->str)
  *p->str++
  // 先读取指针str指向的对象的是，然后+1，然后再读取对应的操作
  (*p->str)++
  // 将指针str指向的对象的值+1
  *p++->str
  // 先读取指针的值，然后再+1
```

* sizeof 返回一个整型值，等于指定对象或者类型占用的存储空间字节数（sizeof返回的是无符号整型值，类型为size_t）

* 条件编译语句#if 中不能使用sizeof，因为预处理器不对类型名进行分析。但是预处理器并不计算#define语句中的表达式。因此在#define中使用sizeof是合法的

* 两个指针之间的加法运算是非法的，但是减法运算是合法的

* 在C语言中，以重合适的方法是将malloc的返回值声明为要给指向void类型的指针，然后再显式的将该指针强制转换为所需的类型

* typdef并没有创建一个新的类型，只是为了这个已经存在的类型增加了一个新的名称。typedef类似于#define语句，但是由于typedef是由编译器解释的，因此他的文本替换能力要超过预处理器的能力。例如

  ```c++
  typedef int (*PFI)(char *, char *);
  ```

  该语句定义了类型PFI是一个指向函数的指针，这个函数拥有两个char*类型的参数，返回类型为int

* typedef的优点，可以使得程序参数话，以提高程序的可移植性。如果typedef声明的数据类型和机器有关，那么只需要改变typedef的类型定义就可以了

* union是可以在不同时刻保存不同类型和长度的对象的变量，编译器负责跟踪对象的长度和对齐要求。

  ```c++
  union u_tag 
  {
    int ival;
    float fval;
    char *sval;  
  }u;
  ```

  变量u必须足够大，以保存这三种类型中的最大的一种。必须保证读取的类型必须是最近一次存入的类型。联合就是要给结构，他的所有的成员变量相对于基地址偏移量都为0.联合只能用其第一个成员类型的值进行初始化（**不能同时初始化两个值**）

* c中的位字段，有些数据在存储的时候并不需要占用一个完整的字节，只需要占用一个或者几个二进制位，基于这种情况，C语言提供了一种叫做位域的数据结构。在结构体定义中，我们可以指定某个成员变量所占用的二进制位数，这就是位域 

  ```c++
  struct 
  {
  	unsigned int is_keyword	: 1;
      unsigned int is_extern  : 1;
      unsigned int is_static  : 1;
  	unsigned n;
  }flags;
  ```

  这里定义了一个变量flags，他包含三个一位的字段，冒号后面的数字表示字段的宽度。

  冒号后面的数字用来限制成员变量占用的位数，成员n没有限制，但是根据数据类型可以推断出是四个字节。其余三个变量被后面的数字限制，不能根据数据类型计算长度。C语言规定，位域的宽度不能超过它所衣服的数据类型的长度；并且只有有限的几种数据类型可以用于位域，包括 int signed int, unsigned int。 到了c99,_bool也开始支持了



