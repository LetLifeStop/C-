第五章 指针与数组

* 指针是能够存放一个地址的一组存储单元，地址运算符&只能应用于内存中的对象，也就是变量和数组元素，不能作用于表达式，常量或者register类型的变量

* ``` c++
  int x = 1, y = 2;
  int *ip;
  
  ip = &x; // 将x的地址赋给ip
  y = *ip; // 将ip这个地址指向的值赋给y
  *ip = 0; // 将ip这个地址指向的值设为0
  ```

* ```c++
  int *ip;
  ```

  上述语句表明表达式*ip的结果是int类型

* 每个指针都必须指向某种特定的数据类型（一个例外是指向void类型的指针，可以存放指向任何类型的指针，但是它不能简介引用其自身）

* 一元运算符*和&的优先级比算数运算符的优先级高，因此赋值语句 

  ```
  y = *ip + 1;
  ```

  就是将*ip的值增加10

* 赋值语句 

  ```c++
  *ip += 1;
  ```

  代表将*ip指向的对象的值取出并且+1，然后再将结果赋值给y，等同于 

  ```c++
  ++*ip;
  ```

  或者

  ```c++
  (*ip)++;
  ```

  其中语句(*ip)++的圆括号是必须的，否则表达式将对ip进行+1运算而不是对ip指向的对象进行+1运算。这是因为**类似于\*和++这样的一元算符遵循从右往左的结合顺序**

* 在自定义swap函数的时候，要把参数设置为*，这样参数的话就代表一个地址，然后对参数中对应地址指向的值进行修改

* 通过数组下标能完成的任何操作都能通过指针实现，一般来说，用指针编写的程序比用数组下标编写的程序执行速度快，但是理解稍微困难一些

* 数组名所代表的时该数组最开始的一个而元素的地址，所以

  ```c++
  int *pa;
  int a[10];
  
  pa = &a[0];
  pa = a;
  // 这两句中表达的含义是相同的
  
  pa = &(a + i);
  pa = a[i];
  (pa + i)
  // 上述三个代表的值是相同的
  ```

* 指针和数组的不同，指针是一个变量，所以语句pa = a和pa++都是合法的。但是数组名并不是变量，类似于a = pa和 a++并不能实现

* 在函数定义中，形式参数 char s[]; 和 char *s; 

* c语言保证，0永远不是有效的数据地址。字符串中的字符数有可能超过int类型所能表示的最大范围，头文件中的\<stddef.h>中定义的类型ptrdiff_t足以表示两个指针之间的带符号差值

* 类似于

  ```c++
  printf("hello, world\n");
  ```

  实际上是通过字符指针访问该字符串的。printf接受的是一个指向字符数组第一个字符的指针

* ```c++
  char *pmessage;
  pmessage = "now is the time";
  ```

  第二个语句的执行过程并没有进行字符串的复制，而只是涉及到指针的操作。

  ```c++
  char amessage[] = "now is the time";
  char *pmessage = "now is the time";
  ```

  第一个语句是一个仅仅足够存放初始化字符串和空字符'\\0'的一维数组，数组的单个字符可以进行修改，但是amessage始终指向同一个存储位置

  第二个语句pmessage是一个指针，初值是一个字符串常量。之后pmessage可以被修改以指向其他地方，但是并不能修改字符串中的内容

* 如果将二位数组作为参数传递给函数，那么在函数的参数声明中必须指定数组的列数。（数组的行数并没有太大的关系，函数调用的时候传递的是一个指针，指向由行向量构成的一维数组）

  ```c++
  f(int sto[2][13])
  {...}
  
  f(int sto[][13])
  {...}
  
  f(int (*sto)[13])
  {...}
  ```

* 假设有如下两个定义

  ```c++
  int a[10][20];
  int *b[10];
  ```

  对a来说，分配了200个int类型长度的存储空间。但是对b来说，只是分配了10个指针

* argc用于参数计数，argv是一个指向字符串数组的指针

  ```c++
  int main(int argc, char *argv[])
  {
      return 0;
  }
  
  int (*comp)(void *, void *);
  // 表明comp是一个指向函数的指针
  
  int *comp(void *, void *);
  // 表明comp是一个函数
  ```

   

  













